//------------------------------------------------------------------------------
// Orig: 2019.11.10 - Alex Israels
// Revs: 2019.11.16 - Alex Israels
// Prog: fcrpt.c
// Func: Encrypts and decrptes a file, depending on the input of the user
// Vars: TBD
//------------------------------------------------------------------------------

#include <openssl/evp.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <termios.h>
#include <sys/time.h>
#include <sys/resource.h>

#define KEYLEN     16
#define MAXKEYLEN  16
#define DIGLEN     20
#define BLOCKSIZE   8
#define STDIN_FD    0
#define BUFSIZE    10

void initializeKey(unsigned char *key, int length)
{
	FILE * rng;
	int  num = 0;

	rng = fopen("/dev/urandom", "r");

    if (rng == NULL)
    {
        printf("Error: Unable to initialize key.\n");
        exit(1);
    }

	while (num < length) {
		num += fread(&key[num], 1, length - num, rng);
	}

	fclose(rng);
}

void printHex(FILE * f, unsigned char *s, int len)
{
	int i;
	for (i = 0; i < len; i++) {
		fprintf(f, "%02x", s[i]);
	}
}

unsigned char * allocateCiphertext(int mlen)
{
	/* Alloc enough space for any possible padding. */
	return (unsigned char *) malloc(mlen+BLOCKSIZE);
}

void secureCoreDump()
{  
    struct rlimit plimits;
    if (getrlimit(RLIMIT_CORE, &plimits) < 0)
    {
        printf("Error: Unable to get current core properties.\n");
        exit(1);
    }
    plimits.rlim_cur = 0;
    plimits.rlim_max = 0;
    if (setrlimit(RLIMIT_CORE, &plimits) < 0)
    {
        printf("Error: Unable to set current core properties.\n");
        exit(1);
    }
}

int main (int argc, char* argv[])
{
    struct termios termInfo;        // Struct for terminal echo
    struct stat    fstats;          // Struct for file stats

    EVP_MD_CTX     * shactx;        // Context of SHA1
    EVP_CIPHER_CTX * ctx;           // Context of file d/ecryption
    EVP_CIPHER_CTX * keyCtx;        // Context of key  d/ecryption
    EVP_CIPHER     * cipher;        // Resulting File Cipher
    EVP_CIPHER     * keyCipher;     // Resulting Key Cipher

    char phrase1[80];        // Holds the 1st passphrase from the user
    char phrase2[80];        // Holds the 2nd passphrase from the user
    char buf[BUFSIZE];       // Buffer of BUFSIZE for reading and writing
    char ** digest;          // Digest generated from passphrase
    char *  encFileName;     // Name of datafile.enc

    char ivec[EVP_MAX_IV_LENGTH] = {0}; // Initialization vector for BF algo

    unsigned char kPass[DIGLEN];    // Kpass generated from SHA1
    unsigned char kEnc [KEYLEN];    // Kenc generated from /dev/urandom
    unsigned char * ciphertext;     // Ciphertext generated by BF algo
    unsigned char * res;            // Result of key decryption
    unsigned char * fileResult;     // Result of file decryption

    int messLen = KEYLEN; // Length of message to encrypt
    int prompting  = 1;   // Boolean for prompting loop
    int passLen    = 0;   // Length of passphrase
    int mode       = 0;   // Mode of application 1 = encrypt, -1 = decrypt
    int dataFile   = 0;   // File descriptor for dataFile
    int encFile    = 0;   // File descriptor for dataFile.enc
    int keyFile    = 0;   // File descriptor for keyFile
    int sha1Len    = 0;   // Length of kPass generated from SHA1
    int ctLen      = 0;   // Length of ciphertext
    int outLen     = 0;   // Length of decrypted result
    int keyMLen    = 0;   // Length of kEnc
    int i          = 0;   // Iterator for loops

    // Error checking for invocation
    if (argc != 4)
    {
        printf("Error: Invalid invocation. Please run with following format:\n");
        printf("./fcrypt <mode> <datafile> <keyfile>\n");
        exit(1);
    }

    // Secure Core
    secureCoreDump();

    // Assign mode
    if (strcmp(argv[1], "-e") == 0)
    {
        mode  = 1;
    }
    else if (strcmp(argv[1], "-d") == 0)
    {
        mode = -1;
    }
    else
    {
        printf("Error: Invalid mode. Mode must be '-e' or '-d'.\n");
        exit(1);
    }

    // Turn off terminal echo
    if (tcgetattr(STDIN_FD, &termInfo) == -1)
    {
        printf("Error: Unable to get terminal info.\n");
        exit(1);
    }
    termInfo.c_lflag &= ~ECHO;
    if (tcsetattr(STDIN_FD, TCSAFLUSH, &termInfo) == -1)
    {
        printf("Error: Unable to set terminal info.\n");
        exit(1);
    }

    // Loop for getting valid passphrase
    while (prompting == 1)
    {
        // Prompt user for passphrase
        printf("Enter a passphrase: ");
        scanf("%[^\n]%*c", phrase1);
        printf("\n");

        // Prompt user for second passphrase
        printf("Verify  passphrase: ");
        scanf("%[^\n]%*c", phrase2);
        printf("\n");

        // If equal then check length
        if (strcmp(phrase1, "") == 0 || strcmp(phrase2, "") == 0)
        {
            printf("Error: No phrase entered.\n");
            exit(1);
        } 
        else if (strcmp(phrase1, phrase2) == 0)
        {
            // If in range of 10 to 80 characters break loop
            passLen = strlen(phrase1);
            if (passLen >= 10 && passLen <= 80)
            {
                prompting = 0;
            }
            else
            {
                printf("Phrase invalid phrase length.\n");
                printf("The phrase must be between 10 and 80 characters.\n");
            }
        }
        else 
        {
            printf("Phrases are not equal. Please try again.\n");
        }
    }

    // Turn on terminal echo
    if (tcgetattr(STDIN_FD, &termInfo) == -1)
    {
        printf("Error: Unable to get terminal info.\n");
        exit(1);
    }
    termInfo.c_lflag |= ECHO;
    if (tcsetattr(STDIN_FD, TCSAFLUSH, &termInfo) == -1)
    {
        printf("Error: Unable to set terminal info.\n");
        exit(1);
    }

    // Once a valid passphrase is accepted run SHA1 over phrase to make Kpass
    shactx = EVP_MD_CTX_create();
    EVP_MD_CTX_init(shactx);
    EVP_DigestInit_ex(shactx, EVP_sha1(), NULL);
    EVP_DigestUpdate(shactx, phrase1, passLen);
    EVP_DigestFinal_ex(shactx, kPass, &sha1Len);

    // Check if SHA1 Length is valid
    if (sha1Len != DIGLEN)
    {
        printf("Error: Unexpected digest length %d.", sha1Len);
        exit(1);
    }

    // Print out Kpass in hexadecimal
    printf("Kpass: <");
    printHex(stdout, kPass, sha1Len);
    printf(">\n");

    // Determine invocation and run accordingly
    if (mode == 1) // Encrypt
    {
        // Generate 128 bit random number Kenc from /dev/urandom
        initializeKey(kEnc, messLen);

        // Print out Kenc in hexadecimal
        printf("Kenc:  <");
        printHex(stdout, kEnc, messLen);
        printf(">\n");

        // Encrypt datafile using Blowfish in CBC mode
        // Open datafile
        dataFile = open(argv[2], O_RDONLY);

        // Create encrypted dataFile name
        encFileName = malloc(strlen(argv[2]) + 5);
        strcpy(encFileName, argv[2]);
        strcat(encFileName, ".enc");

        // Open encyrpted dataFile
        encFile = open(encFileName, O_CREAT|O_TRUNC|O_WRONLY|O_NOFOLLOW|O_APPEND, 0400);
        free(encFileName);

        // Set up Blow Fish algorithm
        cipher = (EVP_CIPHER *) EVP_bf_cbc();
        ctx = (EVP_CIPHER_CTX *) malloc(sizeof(EVP_CIPHER_CTX));
        EVP_CIPHER_CTX_init(ctx);
        EVP_EncryptInit_ex(ctx, cipher, NULL, NULL, NULL);
        EVP_CIPHER_CTX_set_key_length(ctx, KEYLEN);
        EVP_EncryptInit_ex(ctx, NULL, NULL, kEnc, ivec);
        ciphertext = allocateCiphertext(BUFSIZE);

        // Write encrypted data to <datafile>.enc
        while ((messLen = read(dataFile, buf, BUFSIZE)) > 0)
        {
            // Encrypt the data
            EVP_EncryptUpdate(ctx, ciphertext, &ctLen, buf, messLen);

            // Write the encrypted data to dataFile.enc
            write(encFile, ciphertext, ctLen);
        }

        // Encrypt and write last block of data
        EVP_EncryptFinal_ex(ctx, ciphertext, &ctLen);
        write(encFile, ciphertext, ctLen);

        // Clean up memory
        free(ciphertext);
        EVP_CIPHER_CTX_free(ctx);
        close(dataFile);
        close(encFile);

        // If keyfile doesn't exist it is created
        keyFile = open(argv[3], O_CREAT | O_TRUNC | O_WRONLY | O_NOFOLLOW | O_APPEND, 0400);

        // Use Kpass to encrypt Kenc
        // Set up Blow Fish algorithm
        keyCtx = (EVP_CIPHER_CTX *) malloc(sizeof(EVP_CIPHER_CTX));
        EVP_CIPHER_CTX_init(keyCtx);
        keyCipher = (EVP_CIPHER *) EVP_bf_cbc();
        EVP_EncryptInit_ex(keyCtx, keyCipher, NULL, kPass, ivec);
        ciphertext = allocateCiphertext(MAXKEYLEN);
        keyMLen = MAXKEYLEN;
        ctLen = 0;
        messLen = 0;
            
        // Encrypt Kenc
        EVP_EncryptUpdate(keyCtx, ciphertext, &ctLen, kEnc, keyMLen);
        EVP_EncryptFinal_ex(keyCtx, &ciphertext[*(&ctLen)], &messLen);
        ctLen += messLen;
        write(keyFile, ciphertext, ctLen);

        // Clean up memory
        close(keyFile);
        free(ciphertext);
        EVP_CIPHER_CTX_free(keyCtx);
    }
    else if (mode == -1) // Decrpyt
    {
        // Print out Kpass in hexadecimal
        printf("Kpass: <");
        printHex(stdout, kPass, sha1Len);
        printf(">\n");

        // Get encrypted Kenc
        keyFile = open(argv[3], O_RDONLY | O_NOFOLLOW);
        
        fstat(keyFile, &fstats);
        ciphertext = malloc(fstats.st_size);
        read(keyFile, ciphertext, fstats.st_size);
        close(keyFile);

        // Decrypt Kenc
        keyCtx = (EVP_CIPHER_CTX *) malloc(sizeof(EVP_CIPHER_CTX));
        EVP_CIPHER_CTX_init(keyCtx);
        keyCipher = (EVP_CIPHER *) EVP_bf_cbc();
        ctLen = fstats.st_size;
        if (EVP_DecryptInit_ex(keyCtx, keyCipher, NULL, kPass, ivec) == 0)
        {
            printf("Error: Initial Decryption of Kenc Failed.\n");
            free(ciphertext);
            EVP_CIPHER_CTX_free(keyCtx);
            exit(1);
        }
        messLen = 0;
        res = (unsigned char *) malloc(ctLen);
        if (EVP_DecryptUpdate(keyCtx, res, &outLen, ciphertext, ctLen) == 0)
        {
            printf("Error: Update Decryption of Kenc Failed.\n");
            free(ciphertext);
            free(res);
            EVP_CIPHER_CTX_free(keyCtx);
            exit(1);
        }
        messLen += outLen;
        if (EVP_DecryptFinal_ex(keyCtx, &res[outLen], &outLen) == 0)
        {
            printf("Error; Final Decryption of Kenc Failed.\n");
            free(ciphertext);
            free(res);
            EVP_CIPHER_CTX_free(keyCtx);
            exit(1);
        }
        messLen += outLen;

        // Print out Kenc in hexadecimal
        printf("Kenc: <");
        printHex(stdout, res, messLen);
        printf(">\n");

        // Clean up memory
        free(ciphertext);
        EVP_CIPHER_CTX_free(keyCtx);

        // Open dataFile.enc
        encFile = open(argv[2], O_RDONLY | O_NOFOLLOW);
        fstat(encFile, &fstats);
        ciphertext = malloc(fstats.st_size);
        read(encFile, ciphertext, fstats.st_size);
        close(encFile);

        // Decrypt dataFile.enc with Kenc
        ctx = (EVP_CIPHER_CTX *) malloc(sizeof(EVP_CIPHER_CTX));
        EVP_CIPHER_CTX_init(ctx);
        cipher = (EVP_CIPHER *) EVP_bf_cbc();
        ctLen = fstats.st_size;
        EVP_DecryptInit_ex(ctx, cipher, NULL, NULL, NULL);
        EVP_CIPHER_CTX_set_key_length(ctx, KEYLEN);

        if (EVP_DecryptInit_ex(ctx, NULL, NULL, res, ivec) == 0)
        {
            printf("Error: Initial Decryption of %s Failed.\n", argv[2]);
            free(res);
            free(ciphertext);
            EVP_CIPHER_CTX_free(ctx);
            exit(1);
        }
    
        messLen = 0;
        outLen = 0;
        fileResult = (unsigned char *) malloc(ctLen);

        if (EVP_DecryptUpdate(ctx, fileResult, &outLen, ciphertext, ctLen) == 0)
        {
            printf("Error: Update Decryption of %s Failed.\n", argv[2]);
            free(res);
            free(fileResult);
            free(ciphertext);
            EVP_CIPHER_CTX_free(ctx);
            exit(1);
        }
        messLen += outLen;

        if (EVP_DecryptFinal_ex(ctx, &fileResult[outLen], &outLen) == 0)
        {
            printf("Error: Final Decryption of %s Failed.\n", argv[2]);
            free(res);
            free(fileResult);
            free(ciphertext);
            EVP_CIPHER_CTX_free(ctx);
            exit(1);
        }
        messLen += outLen;

        // Print out decrypted datafile in hexadecimal
        printf("Datafile   (HEX): <");
        printHex(stdout, fileResult, messLen);
        printf(">\n");

        // Print out decrypted datafile in ascii
        printf("Datafile (ASCII): <");
        for (i = 0; i < messLen; i++)
        {
            printf("%c", fileResult[i]);
        }
        printf(">\n");

        // Clean up memory
        free(res);
        free(fileResult);
        free(ciphertext);
        EVP_CIPHER_CTX_free(ctx);
    }
    else
    {
        printf("Invalid mode. Mode must be '-e' or '-d'.\n");
        exit(1);
    }
    exit(0);
}